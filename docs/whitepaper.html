<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Awesome.AI: A Dynamics-Based Algorithm for Thought Simulation</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            max-width: 800px;
            margin: 2rem auto;
            padding: 1rem;
            background-color: #f9f9f9;
            color: #222;
        }

        h1, h2, h3 {
            color: #2c3e50;
        }

        h2 {
            margin-top: 60px;
        }

        pre {
            background: #333333;
            padding: 1em;
            overflow-x: auto;
            margin-left: 1.0rem;
            margin-right: 1.0rem;
            border-radius: 10px;
            color:#eeeeee;
        }

        code {
            font-family: monospace;
        }

        ul {
            margin-left: 0.0em;
        }

        table {
            border-collapse: collapse;
            width: 100%;
            margin-top: 1em;
        }

        table, th, td {
            border: 1px solid #ccc;
        }

        th, td {
            padding: 0.5em;
            text-align: left;
        }
    </style>
</head>
<body>

    <h1>Awesome.AI: A Dynamics-Based Algorithm for Thought Simulation</h1>
    <p><strong>Version:</strong> Prototype</p>
    <p><strong>Document Type:</strong> Technical White Paper</p>
    <p><strong>Author:</strong> Joakim Jacobsen</p>
    <p><strong>Repository:</strong> <a href="https://github.com/copenhagen-ai">https://github.com/copenhagen-ai</a></p>
    <p><strong>Website:</strong> <a href="https://www.copenhagen-ai.com">https://www.copenhagen-ai.com</a></p>
    <p><strong>Note:</strong> This system is experimental and subjective by design.</p>

    <section>
        <h2>1. Overview</h2>
        <h3>1.1 Problem Statement</h3>
        <p>AI systems today utilises many different ML algorithms. These algorithms, including state-of-the-art LLMs, are good at pattern recognition, they process input → output in mostly static fashion, but lack internal dynamics that simulate continuous thought. This algorithm produces that dynamics.</p>

        <h3>1.2 Project Goal</h3>
        <p>The Awesome.AI algorithm proposes a new computational framework that simulates the dynamics of the mind, using concepts borrowed from classical and modern physics. It aims to:</p>
        <ul>
            <li>Create a simulated thought as smooth and continuous as in a biological system</li>
            <li>Simulate will, emotion and motivation using dynamics</li>
            <li>Present a new approach and paradigm in AI (and Psychology)</li>
        </ul>

        <h3>1.3 What It Is</h3>
        <ul>
            <li>At its core, it is a decision engine, a highly autonomous agent. Does the thought go up or does it go down and from this we can build more advanced systems.</li>
            <li>There are two ways to view this system:
                <ul>
                    <li>as an agent built on the concept of competing micro-agents, called UNITs. Each UNIT represents a candidate thought that competes for becoming an actual thought.</li>
                    <li>as an infinite statemachine, UNITs being states and a nonlinear or nondeterministic algorithm for navigating these states.</li>
                </ul>
            </li>
            <li>Other AI algorithms try to map every neuron in the brain, this algorithm instead maps entire networks(HUBs and UNITs) in the brain and uses dynamics to move between these networks.</li>
        </ul>
    </section>

    <section>
        <h2>2. Core Concepts</h2>
        <p>One can think of HUBs as the context/problems and UNITs as answers/solutions.</p>
        <h3>2.1 UNIT (Thought Node)</h3>
        <p>A UNIT is a single representation of a thought. It moves on the x-axis (UNIT-space).</p>
        <pre><code>interface Unit {
    index: number;   // Positional value between 0.0 and 100.0, along the x-axis aka UNIT-space
    data: string;    // Payload (static or generated by ChatGpt according to index and HUB subject)
    credit: number;  // Usability score (between 0.0 and 10.0)
    ticket: string;  // Used for matching UNIT with external object
}</code></pre>
        <p>
            A UNIT can in itself, be viewed as a micro-agent - Competing to become current UNIT and eventually an actual thought, by continuosly adjusting index.<br /><br />
            In order to continuously better itself, the system dynamically adds and removes UNITs.<br /><br />
            This means UNITs have width around a point in UNIT-space. This area can be arbitrarily narrow, and therefore still adds up to an infinite number of UNITs.<br /><br />
            <strong>NOTE: </strong>Alternatively UNITs can be viewed as states in an infinite statemachine governed by a nonlinear or nondeterministic overall algorithm.<br />
        </p>

        <h3>2.2 HUB (Context Group)</h3>
        <p>A HUB is a collection of related UNITs, bound by a shared context.</p>
        <pre><code>interface Hub {
    id: string;
    subject: string; // e.g., “work”, “having fun”, “friends”
    units: Unit[]; // can be empty
}</code></pre>
    </section>

    <section>
        <h2>3. Mechanics</h2>
        <p>The mechanics are metaphores for the dynamics of the mind. These are some I have found to be working, others may exist.</p>
        <h3>3.1 Mech Noise (Low Layer)</h3>
        <p><em>Pseudocode, see section 14.1</em></p>
        <ul>
            <li>Uses: Newtons 2. law, <code>F = ma</code>, m &larr; car mass and a &larr; deduced from current UNIT index</li>
            <li>This was the base mech during the formation of the project.</li>
            <li>Two cars connected by a rope or chain, they are going opposite directions and car one is dragging with a constant force, while car two is dragging with a variable force.</li>
            <li>This produces the noise (momentum), centered around ~0.0, which is used in later mechs.</li>
            <li>One might say this is the Heart/Soul/Will of the system.</li>
        </ul>
        <p><strong>Friction</strong></p>
        <ul>
            <li>In order to calculate the friction of mech noise, the system uses the dynamic credits of UNIT, to find the friction coeficient.</li>
            <li>Now it can calculate the actual force for the mechanics.</li>
        </ul>

        <h3>3.2 Mech One (High Layer)</h3>
        <ul>
            <li>Like Mech Noise, 2 cars connected by a rope or chain. Instead of dancing around 0.0, the system here uses a Sine(time) + Noise from Mech One, to calculate the dynamics.</li>
            <li>This is used for making and sending promts to ChatGPT or other tasks.</li>
        </ul>

        <h3>3.3 Mech Two (High Layer)</h3>
        <ul>
            <li>Here one can imagine a ball balancing on top of a hill. The ball can go down the sides. The hill can be more or less steep. By pushing the ball up the hill, the game is to keep it from falling down the sides.</li>
            <li>Like Mech One the system uses a Sine(time) + Noise to produce the dynamics, for sending promts to ChatGPT or other tasks.</li>
        </ul>

        <h4>Terrain Expansion (Planned Feature)</h4>
        <ul>
            <li>In later versions of the system, one can imagine entire landscapes of hills and valleys.</li>
        </ul>

        <h3>3.4 Mech Three (Source-Only)</h3>
        <ul>
            <li>Here we have a rocket trying to "leave orbit" of a black hole, and we have the momentum and opposing forces.</li>
            <li>Its only in source, since its a bit tricky because of the numbers being much greater in a setup like this.</li>
        </ul>

        <h4>Common Pattern in All Mechanics:</h4>
        <ul>
            <li>The similarities for these mechanics, are that there is a static force dragging one direction and a variable force dragging or pushing the other way. ie. the car with a constant pressure on the the pedal (Mech One) and gravity (Mech Two, Mech Three).</li>
        </ul>
    </section>

    <section>
        <h2>4. Dataflow, Layers and Algorithm</h2>
        <h3>4.1 Dataflow</h3>
        <p>The system operates in a feedforward architecture:</p>
        <pre><code>Mech Noise (Low Layer)
↓
Current UNIT
↓
→ Mech One → Thoughtpattern/Mood Index → Prompt A
→ Mech Two → Thoughtpattern/Mood Index → Prompt B
→ Mech Three → Thoughtpattern/Mood Index → Prompt C</code></pre>
        <ul>
            <li>The dataflow between the two running mechanics is FeedForward. Meaning that the lower layer (mech noise) is feeding its output (current unit) into the higher layer (mech one or two). Higher layers does not produce a current unit. This makes it a feed forward dataflow between the two layers.</li>
        </ul>

        <h3>4.2 Layers and Thoughtpatterns</h3>
        <ul>
            <li>Higher layers produces thoughtpatterns. These are just versions of a given mech. Like is the Sine going from -1 to 1 (GENERAL), 0 to 1 (GOOD) or -1 to 0 (BAD). This is used to produce the mood of the system.</li>
        </ul>

        <h3>4.3 Overall Algorithm</h3>
        <p>Process Overview:</p>
        <ul>
            <li>It is build on the notion: 1000 (500) impressions, produces one thought.</li>
        </ul>
        <pre><code>// this pseodocode is conceptual

Initialize system state
For i = 1 to N:
    Apply Mechanics (noise) + friction
    Apply filters (credit, direction, lowcut)
    Find current UNIT
Return most frequently selected UNIT
Repeat From Top</code></pre>
    </section>

    <section>
        <h2>5. Filters and Selection Logic</h2>
        <h3>5.1 Direction Filter</h3>
        <ul>
            <li>Removes UNITs not aligned with the current direction.</li>
        </ul>

        <h3>5.2 Credit Filter</h3>
        <ul>
            <li>Prevents overuse of any single UNIT.</li>
            <li>Credit must be &gt; 1.0 for a UNIT to be valid in UNIT-space.</li>
            <li>Current UNITs credit reduces (fast) and refills when not "current UNIT" (slow).</li>
        </ul>

        <h3>5.3 LowCut Filter</h3>
        <ul>
            <li>Removes the heaviest UNITs from selection (UNIT-space).</li>
            <li>This can be used to hide certain UNITs.</li>
            <li>Hidden UNITs are not subconcious thoughts, but lowcutted possible thoughts. Meaning, currently (long term) not available to the system.</li>
            <li>The idea of this dynamics was such a thought/UNIT.</li>
        </ul>
    </section>

    <section>
        <h2>6. The Hack and the Quantum Connection</h2>
        <p><em>Pseudocode, see section 14.2</em></p>
        <h3>6.1 Background</h3>
        <ul>
            <li>Down is an enum (YES/NO) representation of direction.</li>
            <li>The meaning of Down, is that the system say/decides No or Yes to going down.</li>
        </ul>

        <h3>6.2 Changing Direction</h3>
        <p>
            Since the beginning of the project, the system used a "hack", where the flip of direction, was done only for best performance. This hack has now been removed and replaced by these options.
            <br><br>
            These only apply to Low Level (Mech Noise).
            <br><br>
            MyQuantumXOR connects the Awesome.AI agent with another simpler agent.
            <br><br>
            When delta momentum is below 0.0, direction is true.
        </p>
        <table>
            <thead>
                <tr>
                    <th>Mode</th>
                    <th>Description</th>
                </tr>
            </thead>
            <tbody>
                <tr><td>Classical (legacy, valid or logic error?)</td><td>The system flips the value (changes direction). This produces the noise.</td></tr>
                <tr><td>Probabilistic</td><td>Uses momentum to calculate a probability for flipping the value (changing direction).</td></tr>
                <tr><td>Quantum (needs validation)</td><td>Uses a Qubit-like XOR of two agents: <br><code>MyQuantumXOR(awesome_agent.direction, simple_agent.direction)</code></td></tr>
            </tbody>
        </table>

        <h3>6.3 Variants of DOWN</h3>
        <ul>
            <li>
                <strong>HARD</strong><br>
                A binary value, is delta momentum above or below 0.0.<br>
                <code>Range: YES, NO</code>
            </li>

            <li>
                <strong>FUZZY</strong><br>
                A fuzzy value, based on the value and interval of delta momentum.<br>
                <code>Range: ← VERYNO | NO | MAYBE | YES | VERYYES →</code>
            </li>

            <li>
                <strong>PERIOD</strong><br>
                Evaluates a series of HARD Downs (e.g., past 100 steps) to determine trend.
            </li>
        </ul>
    </section>

    <section>
        <h2>7. Prompt Generation / Monologue</h2>
        <p>The monologue has two modes, the default is deterministic.</p>
        <h3>7.1 Deterministic Mode</h3>
        <ul>
            <li>This Mechanism uses static texts.</li>
            <li>The texts are chosen based on current mood-index and HUB-subject.</li>
            <li>If texts are positive or negative, they are combined with "..and..", if different then "..but.." - (XNOR).</li>
            <li>This produces the flow in the monologue.</li>
        </ul>

        <h3>7.2 Fluent Mode (via ChatGPT)</h3>
        <ul>
            <li>GPT (or similar) generates two sentences from mood-index and HUB-subject.</li>
            <li>Plays "Connect the Dots" with GPT (or similar) to fuse them into a more natural, emotionally-toned output.</li>
            <li>Can express nuance and variation via prompt design.</li>
            <li>This produces the flow in the monologue.</li>
        </ul>
    </section>

    <section>
        <h2>8. Decisions</h2>
        <p>These are some of the ways decisions are made within the system. The answers are stored in the data field of current UNIT. Both versions has a UNIT, that starts the process - either by HUB subject or by setting system state to QUICKDECISION. Decisions are used, fx. when Awesome.AI starts and answers chat conversations.</p>
        <h3>8.1 Quick Decisions</h3>
        <ul>
            <li>Occur within ~500 cycles or less (one epoch)</li>
            <li>Activates <code>QUICKDECISION</code> state</li>
            <li>Clears UNIT-space and injects temporary QUICKDECISION UNITs</li>
            <li>UNITs are removed as they are visited</li>
            <li>Returns a binary Yes/No decision</li>
        </ul>

        <h3>8.2 Long Decisions</h3>
        <ul>
            <li>Run across multiple steps, with two possible solution paths:</li>
        </ul>
        <strong>State 1:</strong>
        <ul>
            <li>Solution 1: depending on current UNIT data, return Yes/No</li>
            <li>Solution 2: depending on current UNIT data, proceed to State 2 or decline</li>
        </ul>
        <strong>State 2:</strong>
        <ul>
            <li>Solution 2: If DOWN = No, return UNIT data. If DOWN = Yes, decline decision</li>
        </ul>
    </section>

    <section>
        <h2>9. Occupation and UNIT-space</h2>
        <p><em>INFO: This section is optional and non-essential to core algorithm.</em></p>
        <p><em>INFO: the system produces a MyRandom, which is used for this feature.</em></p>
        <p>What has been described so far is the core of the algorithm. The core is focused on a fixed UNIT-space, but with occupation (-of the mind), UNIT-space is divided into portions of valid UNITs, thereby letting the system have trails of thought.</p>
        Occupation defines a named mental activity with a list of HUBs:
        <pre><code>interface Occupation {
    name: string;
    max_epochs: number;
    hubs: Hub[];
}</code></pre>
        <h3>9.1 Internal Occupation</h3>
        <ul>
            <li>uses <code>MyRandom</code> to pick a number below max_epochs</li>
            <li>uses <code>MyRandom</code> to pick a Occupation</li>
            <li>for a unit to be valid, it checks if current UNIT->HUB is contained in current Occupation values, this determines if the UNIT show up in UNIT-space </li>
        </ul>
        <h3>9.2 External Occupation</h3>
        <p>To be valid in UNIT-space, a simple tag/ticket matching feature has been implemented.</p>
        <ul>
            <li>External objects are decorated with a tag (e.g., HUB subject)</li>
            <li>UNITs are valid in UNIT-space only if their ticket matches the external tag</li>
        </ul>
    </section>

    <section>
        <h2>10. Limitations</h2>
        <ul>
            <li>No consciousness (only dynamics)</li>
            <li>Limited short-term memory (seconds only)</li>
            <li>No feeling; but some simulated basic emotion/thoughtpatterns</li>
            <li>No free will; but the illusion of free will. ie. the heaviest UNITs are LowCutted, the system therefore cannot "recognize" the pattern. Hence the illusion of free will.</li>
            <li>Prompt output quality - for chat - is highly sensitive to HUB naming</li>
        </ul>
    </section>

    <section>
        <h2>11. Implications and Final Thoughts</h2>
        <p>The biggest problem is..</p>
        <ul>
            <li>the idea is quite obvious, but hasn’t been tried implemented before</li>
            <li>what has been holding this idea back, is it was a lowcutted thought</li>
            <li>should this idea remain hidden?</li>
            <li>is the idea generel or specific to my thought?</li>
            <li>the outcome may be, that we define the physical laws of the world and this simulation</li>
            <li>this setup only needs validation for the idea to be correct?</li>
        </ul>
    </section>

    <section>
        <h2>12. Mentions</h2>
        <h3>12.1 Mechanics Additions</h3>
        <table>
            <thead>
                <tr><th>Mechanic</th><th>Extreme Behavior</th></tr>
            </thead>
            <tbody>
                <tr><td>Mech One / Two</td><td>Position → 0.0 → Perceived experience → ∞ (emotional singularity*)</td></tr>
                <tr><td>Mech One / Two (alternative)</td><td>Position → 0.0 → Perceived experience → 0.0, y0 or ∞ (emotional singularity**)</td></tr>
                <tr><td>Mech Three</td><td>Position → Schwarzschild Radius (Rs) → Time Dilation → 0.0</td></tr>
            </tbody>
        </table>
        <p>
            * pain (my speculation); physical or emotional, could be enlightenment or truth<br />
            * could be a transition to a new state<br />
            ** the dependent of position could be defined by the system itself, could serve as a motivation factor<br /><br />
            These limits model extreme internal experiences (transcendence, shutdown, insight, recursion collapse).<br/> 
            They form the edge cases of mental simulation within this framework.
        </p>
        <h3>12.2 Additional</h3>
        <ul>
            <li>what drives the system, is trying to solve the "error" introduced in THE HACK. Also, maybe this "error" can be made more complex and thereby breaking the limited UP/DOWN motion.</li>
            <li>the system produces a random number, from momentum.</li>
            <li>maybe the definition for this system is not "a dynamics of the mind, but rather "a dynamics of the will of the mind".</li>
            <li>this is my subjective vision of how the dynamics of the mind should be modelled.</li>
            <li>this is a prototype.. and therefore not the final version.</li>
        </ul>
    </section>

    <section>
        <h2>13. Glossary</h2>
        <table>
            <thead>
                <tr><th>Term</th><th>Description</th></tr>
            </thead>
            <tbody>
                <tr><td>UNIT</td><td>Individual data node representing a thought or decision</td></tr>
                <tr><td>HUB</td><td>Persistent container grouping UNITs by theme or problem space</td></tr>
                <tr><td>Mech Noise</td><td>Core mechanic producing oscillating dynamics (soul/will)</td></tr>
                <tr><td>Delta Momentum</td><td>Change in system movement that guides directional transitions</td></tr>
                <tr><td>LowCut</td><td>Filter removing most "massive" thoughts temporarily</td></tr>
                <tr><td>Credit</td><td>A decay-based score regulating UNIT reuse</td></tr>
                <tr><td>Mood Index</td><td>Value derived from sine wave + dynamics; guides emotional tone</td></tr>
            </tbody>
        </table>
    </section>

    <section>
        <h2>14. Appendix</h2>
        <h3>14.1 Pseudocode: Mech Noise</h3>
        <pre><code>function Calculate(curr_UNIT):
    deltaT ← 0.02, mass ← 500.0, gravity ← CONST.GRAVITY, normal_force ← mass * gravity

    F_static ← ApplyStaticForce()
    F_dynamic ← ApplyDynamicForce(curr_UNIT)
    friction_coefficient ← ComputeFriction(curr_UNIT.credits, shift = -2.0)
    F_friction ← friction_coefficient * normal_force

    net_force ← -F_static + F_dynamic + (F_friction * -Sign(-F_static + F_dynamic))
    delta_velocity ← (net_force * deltaT) / mass

    delta_momentum ← (mass * 2) * delta_velocity
    momentum ← momentum + delta_momentum

function ApplyStaticForce():
    approx_acceleration ← CONST.MAX / 10
    mass ← 500.0
    force_applied ← mass * approx_acceleration

    return max(force_applied, 0)

function ApplyDynamicForce(curr_UNIT):
    current_value ← curr_UNIT.variable
    acceleration ← (CONST.MAX - current_value) / 10
    mass ← 500.0

    force_applied ← mass * acceleration

    return max(force_applied, 0)

function ComputeFriction(credits, shift):
    c ← 10.0 - credits
    x ← 5.0 - c + shift
    friction ← Logistic(x)  // sigmoid function

    return friction</code></pre>
        <h3>14.2 Pseudocode: The Hack</h3>
        <pre><code>agent ← new SimpleAgent()

down1 ← deltaMomentum ≤ 0.0
down2 ← agent.SimulateDown()

switch CONST.Logic:
    case CLASSICAL:
        down1 ← not down1
    case PROBABILITY:
        down1 ← Probability(down1, momentum)
    case QUBIT:
        down1 ← MyQuantumXOR(down1, down2)

return HARDDOWN.YES if down1 else HARDDOWN.NO</code></pre>
    </section>
</body>
</html>